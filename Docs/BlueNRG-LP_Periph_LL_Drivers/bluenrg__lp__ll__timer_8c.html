<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-LP Peripherals LL drivers APIs: bluenrg_lp_ll_timer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-LP Peripherals LL drivers APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg_lp_ll_timer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides a set of functions to manage the radio and sleep timers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bluenrg__lp__ll__timer_8h_source.html">bluenrg_lp_ll_timer.h</a>&quot;</code><br />
</div>
<p><a href="bluenrg__lp__ll__timer_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtimer__context__s.html">timer_context_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae1010f6bb6df72adfefbcf4290eb9694"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gae1010f6bb6df72adfefbcf4290eb9694">TIME_DIFF</a>(a,  b)          &#160;&#160;&#160;(((int32_t)((a - b) &lt;&lt; (32-<a class="el" href="group___t_i_m_e_r___exported___constants.html#gaf85745c5225a82174705e02da15c4309">TIMER_BITS</a>))) &gt;&gt; (32-<a class="el" href="group___t_i_m_e_r___exported___constants.html#gaf85745c5225a82174705e02da15c4309">TIMER_BITS</a>))</td></tr>
<tr class="separator:gae1010f6bb6df72adfefbcf4290eb9694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb016a73722365d8453eea25a32cdf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gaccb016a73722365d8453eea25a32cdf7">TIME_ABSDIFF</a>(a,  b)          &#160;&#160;&#160;((a - b) &amp; <a class="el" href="group___t_i_m_e_r___exported___constants.html#ga00ba68f62b52b73c91ed948087a5f3df">TIMER_MAX_VALUE</a>)</td></tr>
<tr class="separator:gaccb016a73722365d8453eea25a32cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a,  b)&#160;&#160;&#160;((a) &lt; (b) )? (a) : (b)</td></tr>
<tr class="separator:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gafa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a,  b)&#160;&#160;&#160;((a) &lt; (b) )? (b) : (a)</td></tr>
<tr class="separator:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125af6df2956a88705c7efdba86cabe5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga125af6df2956a88705c7efdba86cabe5">ATOMIC_SECTION_BEGIN</a>()</td></tr>
<tr class="separator:ga125af6df2956a88705c7efdba86cabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfff8120ca5315b54cc5ff907c83902d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gacfff8120ca5315b54cc5ff907c83902d">ATOMIC_SECTION_END</a>()&#160;&#160;&#160;__set_PRIMASK(uwPRIMASK_Bit)</td></tr>
<tr class="separator:gacfff8120ca5315b54cc5ff907c83902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b186f7691a992c50ebbba4e6e759c9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#ga8b186f7691a992c50ebbba4e6e759c9a">MULT64_THR_FREQ</a>&#160;&#160;&#160;(806)</td></tr>
<tr class="separator:ga8b186f7691a992c50ebbba4e6e759c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa486908206f12bafbf4cd6587a3f30ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#gaa486908206f12bafbf4cd6587a3f30ae">MULT64_THR_PERIOD</a>&#160;&#160;&#160;(1589)</td></tr>
<tr class="separator:gaa486908206f12bafbf4cd6587a3f30ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5070712bba21161ad840408134ee229f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#ga5070712bba21161ad840408134ee229f">RX</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga5070712bba21161ad840408134ee229f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b9bd4430d2377182d1c84201fbb9b68"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#ga8b9bd4430d2377182d1c84201fbb9b68">TX</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga8b9bd4430d2377182d1c84201fbb9b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f93239c718e32dd41f970b046af7a7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#ga6f93239c718e32dd41f970b046af7a7d">MARGIN_EXT</a>&#160;&#160;&#160;(200)</td></tr>
<tr class="separator:ga6f93239c718e32dd41f970b046af7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151d82b6beb3cd329c2e1c92f8cd499a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___constants.html#ga151d82b6beb3cd329c2e1c92f8cd499a">WAKEUP_INIT_DELAY</a>&#160;&#160;&#160;(27) /* about 65us in STU */</td></tr>
<tr class="separator:ga151d82b6beb3cd329c2e1c92f8cd499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga535132efc461718adb8d3d52e7d47563"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtimer__context__s.html">timer_context_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___types.html#ga535132efc461718adb8d3d52e7d47563">TIMER_ContextType</a></td></tr>
<tr class="separator:ga535132efc461718adb8d3d52e7d47563"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3128db178d3e2c131cd6e24954c7917a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga3128db178d3e2c131cd6e24954c7917a">TIMER_Init</a> (<a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a> *TIMER_InitStruct)</td></tr>
<tr class="memdesc:ga3128db178d3e2c131cd6e24954c7917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the TIMER functionality.  <a href="group___t_i_m_e_r___exported___functions.html#ga3128db178d3e2c131cd6e24954c7917a">More...</a><br /></td></tr>
<tr class="separator:ga3128db178d3e2c131cd6e24954c7917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eeba98c495209667ba227aac604702a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga0eeba98c495209667ba227aac604702a">TIMER_Calibrate</a> (void)</td></tr>
<tr class="memdesc:ga0eeba98c495209667ba227aac604702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed clock calibration and store results in the global context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration. This function is not re-entrant since it updates the context variable storing the system time.  <a href="group___t_i_m_e_r___exported___functions.html#ga0eeba98c495209667ba227aac604702a">More...</a><br /></td></tr>
<tr class="separator:ga0eeba98c495209667ba227aac604702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b629dcf17ba3268f9241e852464af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga25b629dcf17ba3268f9241e852464af2">TIMER_StartCalibration</a> (void)</td></tr>
<tr class="memdesc:ga25b629dcf17ba3268f9241e852464af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the calibration routine.  <a href="group___t_i_m_e_r___exported___functions.html#ga25b629dcf17ba3268f9241e852464af2">More...</a><br /></td></tr>
<tr class="separator:ga25b629dcf17ba3268f9241e852464af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">TIMER_IsCalibrationRunning</a> (void)</td></tr>
<tr class="memdesc:ga4a4c60a6b58d5991769bf761f08d8921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a calibration is on going. It relies on the value of the interrupt status. Assumption is that no other modules are managing the interrupt status of the calibrator.  <a href="group___t_i_m_e_r___exported___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">More...</a><br /></td></tr>
<tr class="separator:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">TIMER_UpdateCalibrationData</a> (void)</td></tr>
<tr class="memdesc:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the result of the last calibration in the internal context. It updates the XTAL startup time. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration.  <a href="group___t_i_m_e_r___exported___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">More...</a><br /></td></tr>
<tr class="separator:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4903e54c5a624002bebb0936083bd5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga6d4903e54c5a624002bebb0936083bd5">TIMER_GetCurrentSysTime</a> (void)</td></tr>
<tr class="memdesc:ga6d4903e54c5a624002bebb0936083bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current system time in system time unit (STU). This is a counter that grows since the power up of the system and it never wraps.  <a href="group___t_i_m_e_r___exported___functions.html#ga6d4903e54c5a624002bebb0936083bd5">More...</a><br /></td></tr>
<tr class="separator:ga6d4903e54c5a624002bebb0936083bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">TIMER_GetFutureSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga2a5d5795a186f997c752faa6e8b521c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">More...</a><br /></td></tr>
<tr class="separator:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">TIMER_GetPastSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">More...</a><br /></td></tr>
<tr class="separator:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c67015d28baecc93e56488116eb91ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1c67015d28baecc93e56488116eb91ce">TIMER_GetCurrentCalibrationData</a> (<a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a> *data)</td></tr>
<tr class="memdesc:ga1c67015d28baecc93e56488116eb91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current calibration data.  <a href="group___t_i_m_e_r___exported___functions.html#ga1c67015d28baecc93e56488116eb91ce">More...</a><br /></td></tr>
<tr class="separator:ga1c67015d28baecc93e56488116eb91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21717c03ae65000a44c509c5c085f7d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga21717c03ae65000a44c509c5c085f7d1">TIMER_ClearRadioTimer2</a> (void)</td></tr>
<tr class="memdesc:ga21717c03ae65000a44c509c5c085f7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timer2.  <a href="group___t_i_m_e_r___exported___functions.html#ga21717c03ae65000a44c509c5c085f7d1">More...</a><br /></td></tr>
<tr class="separator:ga21717c03ae65000a44c509c5c085f7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">TIMER_ClearRadioTimerValue</a> (void)</td></tr>
<tr class="memdesc:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Wakeup Timer and Timer1.  <a href="group___t_i_m_e_r___exported___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">More...</a><br /></td></tr>
<tr class="separator:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb93a6fc923bc6f2194494e1a679f452"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gafb93a6fc923bc6f2194494e1a679f452">TIMER_GetRadioTimerValue</a> (uint32_t *time)</td></tr>
<tr class="memdesc:gafb93a6fc923bc6f2194494e1a679f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the Radio timers and the last value programmed in the register.  <a href="group___t_i_m_e_r___exported___functions.html#gafb93a6fc923bc6f2194494e1a679f452">More...</a><br /></td></tr>
<tr class="separator:gafb93a6fc923bc6f2194494e1a679f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaeb5e8f8f906d6566837d42c15874e33c">__TIMER_GetSysRfSetupTime</a> (void)</td></tr>
<tr class="memdesc:gaeb5e8f8f906d6566837d42c15874e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last setup time in absolute units needed to the hardware for the last radio operation. Intended to be used only inside the timer module library.  <a href="group___t_i_m_e_r___exported___functions.html#gaeb5e8f8f906d6566837d42c15874e33c">More...</a><br /></td></tr>
<tr class="separator:gaeb5e8f8f906d6566837d42c15874e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">TIMER_SetWakeupTime</a> (uint32_t delay, BOOL allow_sleep)</td></tr>
<tr class="memdesc:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 28 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="group___t_i_m_e_r___exported___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">More...</a><br /></td></tr>
<tr class="separator:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1675fc9629b47a676fea2fccd6680e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gade1675fc9629b47a676fea2fccd6680e">TIMER_SetRadioTimerValue</a> (uint32_t timeout, BOOL event_type, BOOL cal_req)</td></tr>
<tr class="memdesc:gade1675fc9629b47a676fea2fccd6680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs either the Wakeup timer or Timer1. Both timers are able to trigger the radio sequencer. Then, they are able to start a transmission or a reception according to the configured radio ram tables. Only the wakeup timer is able to let the device out from sleep. The wakeup timer is programmed if the anolag part has enough time to settle after the wakeup or not. The timeout passed as parameter represents the moment where the first bit must be transmitted or the receive window must be opened. Since the radio needs some time to setup, the final timeout programmed is compensated by certain time intervals according to the kind of operation (Tx or Rx), calibration request and programmed timer. The wakeup offset is compensated automatically by the hardware. The CPU wakes up at timeout minus wakeup_offset. if the wakeup timer is programmed, the BLE event triggers when the absolute time mathches the 28 MSB of the timeout. Otherwise the trigger event occurs considering all 32 bits.  <a href="group___t_i_m_e_r___exported___functions.html#gade1675fc9629b47a676fea2fccd6680e">More...</a><br /></td></tr>
<tr class="separator:gade1675fc9629b47a676fea2fccd6680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88243574d09e3b9d759930296f08d14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga88243574d09e3b9d759930296f08d14c">TIMER_SetRadioCloseTimeout</a> (void)</td></tr>
<tr class="memdesc:ga88243574d09e3b9d759930296f08d14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the radio timer (a.k.a Timer1) as close as possible. The current time is sampled and increased by two. It means that the timer is going to trigger in a timer interval that goes from one to two machine time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga88243574d09e3b9d759930296f08d14c">More...</a><br /></td></tr>
<tr class="separator:ga88243574d09e3b9d759930296f08d14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4ee819594e0e6369ae440d44a27765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga5a4ee819594e0e6369ae440d44a27765">TIMER_Enable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:ga5a4ee819594e0e6369ae440d44a27765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CPU wakeup interrupt towards the CPU.  <a href="group___t_i_m_e_r___exported___functions.html#ga5a4ee819594e0e6369ae440d44a27765">More...</a><br /></td></tr>
<tr class="separator:ga5a4ee819594e0e6369ae440d44a27765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gaca3f48e042f8663db271f2d2a88d9d01">TIMER_Disable_CPU_WKUP</a> (void)</td></tr>
<tr class="memdesc:gaca3f48e042f8663db271f2d2a88d9d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable CPU wakeup interrupt towards the CPU.  <a href="group___t_i_m_e_r___exported___functions.html#gaca3f48e042f8663db271f2d2a88d9d01">More...</a><br /></td></tr>
<tr class="separator:gaca3f48e042f8663db271f2d2a88d9d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">TIMER_GetAnchorPoint</a> (void)</td></tr>
<tr class="memdesc:ga93c87f2f82ef629a0b3665248b7505e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return timer capture register value in STU.  <a href="group___t_i_m_e_r___exported___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">More...</a><br /></td></tr>
<tr class="separator:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#gae4bc7d35d23ca42e36d630eb5afd38a2">TIMER_SysTimeToMachineTime</a> (int32_t time)</td></tr>
<tr class="memdesc:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MTU corresponding to the STU passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#gae4bc7d35d23ca42e36d630eb5afd38a2">More...</a><br /></td></tr>
<tr class="separator:gae4bc7d35d23ca42e36d630eb5afd38a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">TIMER_MachineTimeToSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga624dafba8076c3ceb2800303e75bf9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the STU corresponding to the MTU passed as parameter.  <a href="group___t_i_m_e_r___exported___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">More...</a><br /></td></tr>
<tr class="separator:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2721cdb6797865137926b3d518d60b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1e2721cdb6797865137926b3d518d60b">TIMER_UsToSystime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1e2721cdb6797865137926b3d518d60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into sys time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga1e2721cdb6797865137926b3d518d60b">More...</a><br /></td></tr>
<tr class="separator:ga1e2721cdb6797865137926b3d518d60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606d739c79f37bab156a7dda5e27f69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___exported___functions.html#ga1606d739c79f37bab156a7dda5e27f69">TIMER_UsToMachinetime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1606d739c79f37bab156a7dda5e27f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate time in microseconds into machine time units.  <a href="group___t_i_m_e_r___exported___functions.html#ga1606d739c79f37bab156a7dda5e27f69">More...</a><br /></td></tr>
<tr class="separator:ga1606d739c79f37bab156a7dda5e27f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides a set of functions to manage the radio and sleep timers. </p>
<dl class="section author"><dt>Author</dt><dd>RF Application Team</dd></dl>
<p>The basic support is provided by a low speed oscillator with a nominal speed of 32.768 kHz. The low speed oscillator provides a counter that increments at a nominal rate of 30.52 us. The counter is 32 bits wide and the low speed oscillator only increments bits 31:4 (most significant 28 bits) The remaining 4 bits are interpolated using the high speed 16 MHz clock. The counter unit are called conventionally machine time unit (MTU). At the end, the counter resolution will be about 1.91 us and it will wrap about every 2.30 hours. It is important to notice that the interpolated bits will only be functional when the system is out of sleep. While in sleep only the 28 most significant bits will tick. The user can setup a timer that will wakeup the system (if asleep) and it will trigger an interrupt when the timer expires. The user timer will not take into account the high speed XTAL wakeup time. The possible options for the low speed oscillator are:</p><ul>
<li>external 32.768 kHz XTAL</li>
<li>internal ring oscillator (RO)</li>
</ul>
<p>The external 32 kHz XTAL meets the assumption made above regarding the nominal speed. The internal RO is sensitive to temperature. Due to this reason, the concept of calibration or compensation is introduced. The calibration process involves measuring the nominal 32 kHz period using the high speed 16 MHz clock, once this operation is performed, the software will compensate all the timing using the most recent calibration value. The calibration is started by hardware at power-on and software in all the other cases. In order to cope with this variation a concept of system time unit (STU) is introduced. The STU is defined as scaled clock compared to MTU in order to:</p><ul>
<li>handle variation of internal RO</li>
<li>express easily timing dictated by Bluetooth Low Energy protocol.</li>
</ul>
<p>The STU are absolute units of time and each unit represent 625/256 us, that is about 2.44 us. The MTU, on the other hand, have a nominal value of 1.91 us, and this value can be assumed constant when using external 32 kHz clock, but it will vary (mainly with temperature variation) when using internal RO. As a design choice, use of MTU is reserved as much as possible to the driver, while STU is exposed to user. This software layer provides also the possibility to program a radio timer linked to an already configured radio event. The radio timer is clocked by the low speed oscillator too.</p>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT 2020 STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="bluenrg__lp__ll__timer_8c_source.html">bluenrg_lp_ll_timer.c</a>.</p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2020 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
